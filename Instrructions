LifeFile Mobile App Project Structure Guide

Lifefile, a cross-platform, patient-centric mobile app using React Native (with Expo Go) and a microservices backend in Spring Boot1. The app targets iOS and Android, with three main user roles: patient, doctor, and admin. 

Part 1: Project Overview
Your LifeFile app has three user roles:
1.	Patients
2.	Doctors
3.	Admins

The app will offer these key features:
•	User authentication (signup/login)
•	Medical history tracking
•	Appointment notifications
•	Health predictions and recommendations
•	Doctor discovery
•	Health analytics and visualization
•	Medical record management

Patient-Side Walkthrough
1. App Launch & Navigation Flow
•	Landing Page: Upon tapping the app icon, users see a landing page.
•	Welcome Page: Next, users are directed to a welcome page.
•	Login/Signup:
o	Login: Patients enter credentials. Success leads to their profile; failure displays an error message.
o	Signup: Unregistered users can sign up, which involves:
	Email and password registration.
	Contact information (name, age, DOB, NIC, etc.).
	Health profile (current health status, height, weight, blood group, etc.).
2. Authentication
•	Uses Firebase Authentication for email/password and Google sign-in.
3. Post-Login Functionalities
•	Medical History Tracking: Patients can view and manage their medical records, prescriptions, drugs, lab tests, and reports.
•	Notifications: Automated reminders for upcoming appointments and lab reports.
•	Personalized Health Recommendations: AI-driven suggestions for exercises, lab tests, and meal plans based on health data. The AI model is trained in Python and integrated into the backend.
•	Doctor Search & Appointments: Patients can search for doctors by specialty and book appointments via an e-channeling site.
•	Health Analytics: Visual graphs and percentage analyses (e.g., sugar and pressure levels) over time, available monthly and annually.
•	Medical Record Management: Patients can upload new records and edit their profiles.
________________________________________
Technology Stack 
•	Frontend: React Native + Expo
•	Backend: Spring Boot microservices
•	Authentication: Firebase Authentication
•	Database: MongoDB (document-based structure fits your models)
•	File Storage: Firebase Storage for medical files
•	Service Registry: Netflix Eureka
•	API Gateway: Spring Cloud Gateway
•	Cross-service Communication: Spring Cloud OpenFeign

Technical Architecture Overview
Frontend:
•	Built with React Native (TypeScript) and Expo Go for rapid development and cross-platform compatibility1.
•	UI components may leverage React Icons for consistency and visual clarity2.
Backend:
•	Microservices architecture using Spring Boot for modularity and scalability1.
•	Each major feature (authentication, medical records, notifications, analytics, AI recommendations, etc.) can be a separate microservice.
•	AI models for recommendations are developed in Python and exposed via REST APIs.
Authentication:
•	Firebase Authentication handles user sign-up, login, and social authentication (Google).
Data Flow:
•	The mobile app communicates with backend microservices through RESTful APIs.
•	Patient data is securely stored and retrieved as needed for medical history, analytics, and recommendations.
________________________________________
Summary Table: Patient-Side Features
Feature	Description	Technology/Service Used
Authentication	Email/password & Google login, registration, error handling	Firebase Authentication
Medical History Tracking	Access to records, prescriptions, drugs, lab tests, reports	Microservices (Spring Boot)
Notifications	Reminders for appointments and lab reports	Microservices (Spring Boot)
Health Recommendations	AI-powered suggestions for exercise, labs, meals	Python AI Model, REST API
Doctor Search & Appointments	Find doctors, book via e-channeling	Microservices, External API
Health Analytics	Graphs and reports on health metrics (sugar, pressure, etc.)	Microservices, Chart Libraries
Record Management	Upload new records, edit profile	Microservices (Spring Boot)
________________________________________
This structure ensures a seamless, secure, and scalable experience for patients, leveraging modern cross-platform and microservices technologies.


Part 2: Frontend Structure (React Native with Expo)

Frontend Folder Structure
Frontend/
├─ assets/             # Images, fonts, etc.
├── app/                # Main screens using file-based routing
│   ├── common/         # Common screens (landing, welcome)
│   ├── auth/           # Authentication screens
│   │   └── patientAuth/ # Patient-specific auth flows
│   ├── patientProfile/ # Patient dashboard and features 
│   ├── doctorProfile/  # Doctor dashboard and features
│   └── adminProfile/   # Admin dashboard and features
├── components/         # Reusable UI components
├── constants/          # App constants and theme
├── hooks/              # Custom React hooks
├── services/           # API services and data fetching
├── utils/              # Helper functions
└── context/            # React context for state management

Authentication Flow

1.	Landing page (landingpage.tsx)
2.	Welcome screen (welcomeScreen.tsx)
3.	Login screen (login.tsx)
4.	Signup process:
o	Account details (signup.tsx)
o	Personal information (createProfile.tsx)
o	Health profile (healthProfile.tsx)
5.	Patient home (patientHome.tsx)

Part 3: Backend Architecture (Spring Boot Microservices)

Backend Folder Structure
Backend/
├── api-gateway/              # API Gateway service
├── discovery-service/        # Service discovery (Eureka)
├── auth-service/             # Authentication and user management
├── patient-service/          # Patient data and operations
├── doctor-service/           # Doctor data and operations
├── medical-records-service/  # Medical history management
├── appointment-service/      # Appointment scheduling
├── notification-service/     # Notifications and reminders
├── analytics-service/        # Health data analytics
├── recommendation-service/   # AI-based recommendations
└── file-storage-service/     # Medical file storage

Microservices Implementation
1.	API Gateway
o	Single entry point for all client requests
o	Routes requests to appropriate microservices
o	Handles authentication token validation
2.	Discovery Service
o	Netflix Eureka for service registration and discovery
o	Enables services to find and communicate with each other
3.	Auth Service
o	Integrates with Firebase Authentication
o	Manages user registration, login, and authorization
o	Issues JWT tokens for authenticated sessions
auth-service/
├── src/main/java/com/lifefile/auth/
│   ├── controller/
│   │   └── AuthController.java
│   ├── service/
│   │   └── AuthService.java
│   ├── model/
│   │   └── User.java
│   └── config/
│       └── SecurityConfig.java
4.	Doctor Service
o	Manages doctor profiles and specializations
o	Handles doctor discovery functionality
o	Manages doctor availability
doctor-service/
├── src/main/java/com/lifefile/doctor/
│   ├── controller/
│   │   ├── DoctorController.java
│   │   └── AppointmentController.java
│   ├── service/
│   │   ├── DoctorService.java
│   │   └── AppointmentService.java
│   ├── repository/
│   │   ├── DoctorRepository.java
│   │   └── AppointmentRepository.java
│   └── model/
│       ├── Doctor.java
│       └── Appointment.java
5.	Appointment Service
o	Manages doctor appointments
o	Integration with e-channeling services
o	Appointment scheduling and management
6.	Notification Service
o	Sends reminders for appointments
o	Alerts for new lab results
o	Medication reminders
notification-service/
├── src/main/java/com/lifefile/notification/
│   ├── controller/
│   │   └── NotificationController.java
│   ├── service/
│   │   └── NotificationService.java
│   └── model/
│       └── Notification.java
7.	Analytics Service
o	Processes health data
o	Generates health trend reports
o	Creates visualizations for the app
analytics-service/
├── src/main/java/com/lifefile/analytics/
│   ├── controller/
│   │   └── AnalyticsController.java
│   ├── service/
│   │   └── AnalyticsService.java
│   └── model/
│       └── HealthMetrics.java
8.	Recommendation Service
o	AI model for health recommendations
o	Exercise and meal plan suggestions
o	Preventive health checks

recommendation-service/
├── src/main/java/com/lifefile/recommendation/
│   ├── controller/
│   │   └── RecommendationController.java
│   ├── service/
│   │   └── RecommendationService.java
│   └── model/
│       └── Recommendation.java
9.	Consolidation of 3 microservices - File Storage Service, Medical Records Service, Patient Service and create new microservice as “Patient Management Service”.
1.	Patient Service
o	Manages patient profiles and personal information
o	Stores health profiles and basic medical information
o	Provides APIs for profile management
2.	Medical Records Service
o	Stores and retrieves patient medical history
o	Manages prescriptions, medications, and treatments
o	Provides API for uploading new records
3.	File Storage Service
o	Handles medical file uploads (lab reports, prescriptions)
o	Secure file storage and retrieval

Benefits of Consolidation
•	Reduced Complexity: Fewer services means simpler deployment, monitoring, and maintenance
•	Fewer Network Calls: Data related to patients and their records would be accessible without API calls between services
•	Simplified Development: One codebase instead of three means faster initial development
•	Resource Efficiency: Less overhead from running multiple services
This handles : - Patient profile management
-	Medical records CRUD operations
-	File storage and retrieval for medical documents
Structure for Consolidated Service
     patient-management-service/
├── src/main/java/com/lifefile/
│   ├── controller/
│   │   ├── PatientController.java
│   │   ├── MedicalRecordController.java
│   │   └── FileStorageController.java
│   ├── service/
│   │   ├── PatientService.java
│   │   ├── MedicalRecordService.java
│   │   └── FileStorageService.java
│   ├── repository/
│   │   ├── PatientRepository.java
│   │   └── MedicalRecordRepository.java
│   └── model/
│       ├── Patient.java
│       ├── MedicalRecord.java
│       └──Medical FileMetadata.java
└── resources/
    └── application.properties



Part 4: Implementation Steps
Phase 1: Setup & Authentication
1.	Complete the frontend authentication flow
2.	Set up Spring Boot project structure with basic microservices
3.	Implement Auth Service with Firebase integration
Phase 2: Core Patient Functionality
1.	Implement Patient Service (with consolidated functionality)
-	Build the patient dashboard
-	Implement medical history viewing
-	Create health analytics screens
2.	Connect frontend patient screens to backend
3.	Implement medical record storage and retrieval
Phase 3: Doctor & Appointment Features
1.	Implement Doctor Service
2.	Add doctor discovery to frontend
3.	Implement appointment booking integration
Phase 4: Advanced Features
1.	Implement Analytics Service for health trends
2.	Set up Notification Service for reminders
3.	Build Recommendation Service with AI integration
Phase 5: Testing & Refinement
1.	End-to-end testing of core flows
2.	Performance optimization
3.	UI/UX refinements
	Step 2: Set Up Backend Infrastructure
1.	Create a parent Maven/Gradle project for all microservices
2.	Set up Spring Cloud Config Server for centralized configuration
3.	Implement Eureka Service Discovery
4.	Create the API Gateway with Spring Cloud Gateway
Step 3: Implement Core Microservices
Start with these essential services:
1.	Auth Service (Firebase integration)
2.	Patient Service
3.	Medical Records Service
Step 4: Develop Advanced Features
Once the core is working:
1.	Analytics Service with data visualization
2.	Recommendation Service with AI model
3.	Notification Service for reminders
Step 5: Connect Frontend and Backend
1.	Create API services in the frontend
2.	Implement JWT token handling
3.	Connect each screen to relevant backend services













Part 5: Database Structure
Patient Collection
{
  uid: String,
  email: String,
  personal: {
    fullName: String,
    dateOfBirth: String,
    nic: String,
    gender: String,
    address: String,
    contactNumber: String,
    profilePicture: String
  },
  health: {
    weight: String,
    height: String,
    bmi: String,
    bloodType: String,
    allergies: String,
    chronicDiseases: String,
    surgeries: String,
    medications: String,
    ongoingTreatments: String,
    lifestyle: {
      smoker: String,
      dietaryPreference: String,
      alcoholConsumption: String,
      hereditaryConditions: String
    }
  },
  medicalRecords: [
    {
      id: String,
      type: String, // prescription/labReport/etc
      date: Date,
      doctorId: String,
      hospitalId: String,
      details: Object,
      fileUrl: String
    }
  ]
}


Doctor Collection
{
  uid: String,
  email: String,
  personal: {
    fullName: String,
    specialization: String,
    hospital: String,
    contactNumber: String,
    profilePicture: String
  },
  availability: [
    {
      day: String,
      startTime: String,
      endTime: String
    }
  ],
  patients: [String] // patient UIDs
}

Conclusion
This structure provides a solid foundation for your LifeFile mobile app. Start with implementing the authentication flow, then progressively add features as you complete each section.
For development:
1.	Start with your Firebase authentication implementation
2.	Build the patient flows first, as they're your primary users
3.	Use placeholder data while developing the UI
4.	Gradually replace with actual API calls as you build each microservice


Microservice 1 - Auth service


